# Software Testing

# Introduction

Software testing is a crucial aspect of testing for our applications. It ensures stability and resilience by validating the performance of individual modules. The most important advantage of unit testing is **automation**, we can write hundreds of test each run in a matter of milliseconds whenever we need, for example, when we made a major or even a minor change in the code.

The framework we use for testing our applications is Jest.

# Tutorial

## Writing Tests with Jest

To write tests with Jest, we need to create a file with a **.test.js**/**.test.ts** extension. Then, we can write our individual test cases using the `test` or `it` function provided by Jest.

We can use various matchers to check whether the expected output of the function is what we actually receive.

For example, if we have a function named `add` that takes in two numbers and returns their sum, we can write a test case like this:

```jsx
test("adds 1 + 2 to equal 3", () => {
  expect(add(1, 2)).toBe(3);
});
```

This test case will pass if the `add` function correctly adds 1 and 2 to return 3. We can run all of our tests using the command `npm test` or `yarn test` in the terminal.

There are many test naming conventions:

[Naming Your Unit Tests: It Should vs. Given/When/Then](https://markus.oberlehner.net/blog/naming-your-unit-tests-it-should-vs-given-when-then/)

If we want to group related tests, in the context of a class for example, it’s better to use the `describe` function. Let’s suppose we have a class named `Calculator` and we want to test its methods, we could write the tests like this:

```jsx
describe("Calculator class", () => {
  describe("sum method", () => {
    it("Should sum two positive numbers", () => {
      const calc = new Calculator();
      let result = calc.sum(2, 3);
      expect(result).toBe(5);
    });
    it("Should sum two negative numbers", () => {
      const calc = new Calculator();
      let result = calc.sum(-2, -3);
      expect(result).toBe(-5);
    });
  });
  describe("sub method", () => {
    it("Should subtract two positive numbers", () => {
      const calc = new Calculator();
      let result = calc.sub(3, 2);
      expect(result).toBe(1);
    });
    it("Should subtract two negative numbers", () => {
      const calc = new Calculator();
      let result = calc.sub(-3, -2);
      expect(result).toBe(-1);
    });
  });
});
```

Let’s say that we want to set the angle unit of measure to degrees and that we want our Calculator to clear its state after each test. We can do that with `beforeAll` and `beforeEach` (for the sake of simplicity, we’ll assume that `Calculator` is a **Singleton Class**, [https://refactoring.guru/design-patterns/singleton/typescript/example](https://refactoring.guru/design-patterns/singleton/typescript/example))

```tsx
import { Calculator } from "./Calculator";

describe("Calculator class", () => {
  beforeAll(async () => {
    Calculator.instance.setAngleMeasurement("Degrees");
  });

  beforeEach(async () => {
    Calculator.instance.clearState();
  });

  describe("sum method", () => {
    it("Should sum two positive numbers", () => {
      let result = Calculator.instance.sum(2, 3);
      expect(result).toBe(5);
    });
    it("Should sum two negative numbers", () => {
      let result = calc.sum(-2, -3);
      expect(result).toBe(-5);
    });
  });
  describe("sub method", () => {
    it("Should subtract two positive numbers", () => {
      let result = Calculator.instance.sub(3, 2);
      expect(result).toBe(1);
    });
    it("Should subtract two negative numbers", () => {
      let result = Calculator.instance.sub(-3, -2);
      expect(result).toBe(-1);
    });
  });
});
```

## Setup Jest

Setup Jest in our project is really easy. All we have to do is to install `jest` as a **devDependency** and write some configurations to better suit our needs.

```json
{
  "name": "example",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "jest"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "jest": "^29.6.1"
  }
}
```

```jsx
//jest.config.js
module.exports = {
  testEnvironment: "node",
  testMatch: ["**/*.test.ts"],
};
```

We can now write our tests in a separated and dedicated folder.

Here’s a nice video that visually guides you through the steps:

[Introduction To Testing In JavaScript With Jest](https://www.youtube.com/watch?v=FgnxcUQ5vho)

## Mocking with Jest

Sometimes, our functions may rely on external APIs or other functions that are not within our control. In these cases, we can use Jest's mocking feature to simulate the behavior of these external dependencies. For example, if we have a function named `getWeather` inside a class named `weatherUtils` that relies on an external API to get the current weather, we can write a mock function like this:

```jsx
// weatherUtils.test.js
const getWeather = require("./weatherUtils");

jest.mock("./weatherUtils", () => {
  return {
    getWeather: (city, zipCode) => {
      return 25;
    },
  };
});

test("Test mock", () => {
  const result = getWeather("London", "E1 6AN");
  expect(result).toBe(25);
});
```

This mock function will replace the `getWeather` function in our application with a Jest mock function that returns a temperature of 25 degrees Celsius. This allows us to test our function even if the external API is down or unreliable.

## Advanced Mocking

Let’s suppose that we want to mock a class full of complex methods and of which we only have got the interfaces avaiable, so we don’t know anything about the code inside since we use it as black box (for example, in our case, AWS SDK). Let’s also suppose we want to emulate what it does. So, our best bet here is to write a class ourselves.
